<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.29 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="networknames" category="info">

  <front>
    <title abbrev="NetworkNames">Network Names</title>

    <author initials="C." surname="Ghali" fullname="Cesar Ghali">
      <organization>University of California Irvine</organization>
      <address>
        <email>cghali@uci.edu</email>
      </address>
    </author>
    <author initials="G." surname="Tsudik" fullname="Gene Tsudik">
      <organization>University of California Irvine</organization>
      <address>
        <email>gts@ics.uci.edu</email>
      </address>
    </author>
    <author initials="C.A." surname="Wood" fullname="Christopher A. Wood">
      <organization>University of California Irvine</organization>
      <address>
        <email>woodc1@uci.edu</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>ICNRG Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>We describe a scheme for “network names” in CCN and related ICN architectures.
Network names are representations for standard application names that are based
on hash functions. Their purpose is to reduce the network workload, enforce
uniformly sized names, and remove plaintext names from the network layer.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Names in CCN are hierarchical URIs formatted according to the CCNx URI naming scheme <xref target="LCI"/>.
The names are carried verbatim in both Interests and Content Objects (with the exception
of nameless objects) <xref target="SEMANTICS"/>. In this note, we make a case for a distinguished type of
name in CCN wherein <spanx style="emph">application names</spanx> formatted according to <xref target="LCI"/> are transformed to
<spanx style="emph">network names</spanx> that are carried in network packets. In this memo, we present the
motivation for this new type of name and provide one transformation scheme to map
application to network names. We also discuss the forwarder implications and necessary
changes to the request and response matching algorithm.</t>

</section>
<section anchor="motivation" title="Motivation">

<t>Currently, the only utility CCN names in Interests afford to the network (i.e., forwarders)
is to serve as a locator for the desired Content Object. The semantic meaning of a name,
as decided by the application, is of no consequence to a forwarder. Names are opaque
locators used to route Interests towards some authoritative source for the corresponding
Content Objects. Names in Content Objects are only used to match against a PIT entry to
forward the message to downstream forwarders. In summary, application semantics have
no use in the data plane of the network. Thus, the application representation of a name
is not needed to enable messages to be correctly forwarded. We therefore seek an
alternative representation that is more network-friendly.</t>

</section>
<section anchor="network-names" title="Network Names">

<t>Let N = [N1, N2, …, Nk] be a CCN name as per <xref target="LCI"/> with k name segments. For example,
the name</t>

<figure><artwork><![CDATA[
    /edu/uci/ics/woodc1
]]></artwork></figure>

<t>is equivalent to the vector</t>

<figure><artwork><![CDATA[
    [edu, uci, ics, woodc1]
]]></artwork></figure>

<t>According to the latest CCN specifications <xref target="LCI"/>, an Interest carrying this name
would have the following TLV-encoded name in the Interest packet. (We use
S-expressions with the length field omitted for simplicity of presentation.)</t>

<figure><artwork><![CDATA[
(T_NAME
    (T_NAMESEGMENT "edu")
    (T_NAMESEGMENT "uci")
    (T_NAMESEGMENT "ics")
    (T_NAMESEGMENT "woodc1")
)
]]></artwork></figure>

<t>In the proposed network name scheme, each name segment would be replaced
by a hash digest. Specifically, the i-th name segment will be replaced
with a hash digest based on the 1,2,…,i name segments. Formally, we
denote this as follows:</t>

<figure><artwork><![CDATA[
N1' = H(N1)
N2' = H(N1 || N2)
N3' = H(N1 || N2 || N3)
...
Ni' = H(N1 || ... || Ni)
...
Nk' = H(N1 || ... || Nk)
]]></artwork></figure>

<t>where H is a hash function which we will define later. Using this construction,
the network name N’ for a given application name N is represented as
N’ = [N1’, N2’, …, Nk’].</t>

<t>In addition to this network name, we also require that packets with names
carry a <spanx style="emph">name fingerprint</spanx> Np, computed as follows:</t>

<figure><artwork><![CDATA[
    Np = CRH(N)
]]></artwork></figure>

<t>where CRH is a collision resistant hash function such as SHA256.</t>

<t>With a suitably chosen H, the relationship between N and N’ forms a bijection.</t>

<section anchor="hash-function-criteria" title="Hash Function Criteria">

<t>Since the name is only used for forwarding purposes, it is not required that
H be a cryptographic hash function. However, it is required for the name fingerprint
function to be a cryptographic hash function. We mandate that this function be the
same of that which is used to compute the ContentObjectHashRestriction that
is specified in <xref target="SEMANTICS"/>.</t>

</section>
<section anchor="packet-format" title="Packet Format">

<t>The network name and fingerprint are represented in the packets as follows.</t>

<figure><artwork><![CDATA[
(T_NAME
    (T_NAMESEGMENT N1')
    ...
    (T_NAMESEGMENT N2')
    (T_NAMEFINGERPRINT Np)
)
]]></artwork></figure>

<t>Contrary to the current encoding outlined in <xref target="SEMANTICS"/>, network names have a
fixed size based on the H. Therefore, we do not need to encode the length
of each name segment block. This saves 2 bytes for each
name component.</t>

<t>In particular, let D be the digest size for H and Dp be the fingerprint
size of CRH. For a name of length L, the number of name segments |N’| can
computed as:</t>

<figure><artwork><![CDATA[
    |N'| = (L - Dp) / (D + 2)   # 2 is for the T byte in each segment
]]></artwork></figure>

<t>The byte offset Bi for the i-th name segment Ni’ is computed as:</t>

<figure><artwork><![CDATA[
    Bi = (D + 2) * i
]]></artwork></figure>

</section>
</section>
<section anchor="forwarder-implications" title="Forwarder Implications">

<t>Network names can be used for routing the say way standard application names are used
in <xref target="SEMANTICS"/>. FIBs must be populated with network names manually or by the routing protocol.
However, what changes is the information stored in the FIB and how Content Object responses
are matched to Interest requests. Currently, Content Objects with names only match
Interests with names if their names are identical. Therefore, when matching a Content
Object with an Interest stored in a PIT entry, a match is only said to occur if
the Interest name fingerprint matches the Content Object name fingerprint. Since these
are computed by CRH (from which collisions occur with negligible probability), this
is no different from comparing the standard application names based on exact match.</t>

</section>
<section anchor="invertible-network-names" title="Invertible Network Names">

<t>Since we use a hash function to compute N’ and Np, one concern is that N would not
be recoverable since hash functions are (in this context) one-way functions.
However, consider the cases when one might need to recover N from N’ and Np.
Inversion is only necessary when there’s application data in the name, i.e.,
there is some data that the producer needs to use to produce a result. Were
this not the case then an Interest could be satisfied by a network cache. This
implies that (a) the producer already generated the <spanx style="emph">same</spanx> content for another
consumer who issued the <spanx style="emph">same request</spanx> and (b) the result will not change from
the producer (assuming identical requests yield identical response).
Thus, we conclude that application data should <spanx style="emph">not</spanx> exist in the name and should
reside in the Payload of an Interest. The Payload ID, which is the hash of the Payload
field in an Interest, is still reflected in the name N and N’, and therefore also Np,
so as to give N’ sufficient randomness to avoid being satisfied by a cache.</t>

<t>In summary, we conclude by observing that Interests convey one of two requests:</t>

<t><list style="numbers">
  <t>Requests for content that already exists. The name is the complete locator
and identifier of the content.</t>
  <t>Requests for content that will be generated on-demand by the producer. The name
is only the locator for the content and the Interest Payload contains data to
be used by the producer to provide the content.</t>
</list></t>

<t>Our network naming scheme permits both types of requests while providing better
separation between locators and identifiers.</t>

</section>
<section anchor="experimental-analysis" title="Experimental Analysis">

<t>We run several experiments to study the overhead of hash based names as compared
to human-readable names.</t>

<t>Current CCNx implementation
uses TLV-based format for human-readable names. In this case, each name component is prepended by $2$ bytes
specifying its type, and $2$ bytes specifying its length. Thus, a total of $4$ bytes
extra are required per components. If names are haseh-based, as described above,
name components will have fixed and pre-determined size. Therefore, only their type is
required, i.e., $2$ extra bytes. We compare the size of both human-readable and hash-based names
using $50$GB of URLs collected from \textcolor{red}{where did the URL came from Chris?} \cite{reference}.</t>

<t>TODO: add the figures of the above experiment.</t>

<t>TODO: run the code to determine how much we save</t>

<t>TODO: compute entropy of URIs as they exist today</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="LCI" target="https://tools.ietf.org/html/draft-mosko-icnrg-ccnxlabeledcontent-01">
  <front>
    <title>Labeled Content Information</title>
    <author initials="." surname="PARC, Inc" fullname="M. Mosko">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SEMANTICS" target="https://datatracker.ietf.org/doc/draft-irtf-icnrg-ccnxmessages/">
  <front>
    <title>CCNx Messages in TLV Format</title>
    <author initials="." surname="PARC, Inc" fullname="M. Mosko">
      <organization></organization>
    </author>
    <author initials="." surname="PARC, Inc" fullname="I. Solis">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>




  </back>
</rfc>

